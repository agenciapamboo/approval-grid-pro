import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.58.0';
import { corsHeaders } from '../_shared/cors.ts';

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Verificar autentica√ß√£o do usu√°rio
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(
        JSON.stringify({ error: 'N√£o autorizado' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Token inv√°lido' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Verificar se √© super_admin
    const { data: roles } = await supabase
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .eq('role', 'super_admin')
      .single();

    if (!roles) {
      return new Response(
        JSON.stringify({ error: 'Acesso negado - apenas super admins' }),
        { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log('üîç Validando secrets do sistema...');

    // Definir secrets cr√≠ticas
    const criticalSecrets = [
      {
        name: 'SUPABASE_SERVICE_ROLE_KEY',
        description: 'Service role do Supabase',
        criticality: 'critical',
        category: 'Database'
      },
      {
        name: 'STRIPE_SECRET_KEY',
        description: 'Secret key do Stripe',
        criticality: 'critical',
        category: 'Payments'
      },
      {
        name: 'STRIPE_WEBHOOK_SECRET',
        description: 'Webhook signing secret do Stripe',
        criticality: 'critical',
        category: 'Payments'
      },
      {
        name: 'FACEBOOK_APP_SECRET',
        description: 'App secret do Facebook',
        criticality: 'critical',
        category: 'Social Media'
      },
      {
        name: 'ADMIN_TASK_TOKEN',
        description: 'Token para cron jobs',
        criticality: 'critical',
        category: 'System'
      }
    ];

    const importantSecrets = [
      {
        name: 'N8N_WEBHOOK_URL',
        description: 'URL do webhook N8N',
        criticality: 'important',
        category: 'Notifications'
      },
      {
        name: 'N8N_WEBHOOK_TOKEN',
        description: 'Token de autentica√ß√£o N8N',
        criticality: 'important',
        category: 'Notifications'
      },
      {
        name: 'APROVA_API_KEY',
        description: 'API key do sistema Aprova',
        criticality: 'optional',
        category: 'Integrations'
      }
    ];

    const autoGeneratedSecrets = [
      {
        name: 'SUPABASE_URL',
        description: 'URL do projeto Supabase',
        criticality: 'auto',
        category: 'Database'
      },
      {
        name: 'SUPABASE_ANON_KEY',
        description: 'Chave p√∫blica do Supabase',
        criticality: 'auto',
        category: 'Database'
      },
      {
        name: 'SUPABASE_PUBLISHABLE_KEY',
        description: 'Alias do anon key',
        criticality: 'auto',
        category: 'Database'
      },
      {
        name: 'SUPABASE_DB_URL',
        description: 'Connection string PostgreSQL',
        criticality: 'auto',
        category: 'Database'
      }
    ];

    // Validar cada secret (apenas presen√ßa, n√£o valor)
    const results = {
      critical: [] as any[],
      important: [] as any[],
      auto: [] as any[]
    };

    let allCriticalPresent = true;

    // Validar cr√≠ticas
    for (const secret of criticalSecrets) {
      const value = Deno.env.get(secret.name);
      const isPresent = value !== undefined && value !== null && value !== '';
      
      results.critical.push({
        name: secret.name,
        description: secret.description,
        category: secret.category,
        present: isPresent,
        status: isPresent ? 'ok' : 'missing'
      });

      if (!isPresent) {
        allCriticalPresent = false;
        console.warn(`‚ùå Secret cr√≠tica ausente: ${secret.name}`);
      } else {
        console.log(`‚úÖ Secret presente: ${secret.name}`);
      }
    }

    // Validar importantes
    for (const secret of importantSecrets) {
      const value = Deno.env.get(secret.name);
      const isPresent = value !== undefined && value !== null && value !== '';
      
      results.important.push({
        name: secret.name,
        description: secret.description,
        category: secret.category,
        present: isPresent,
        status: isPresent ? 'ok' : 'missing'
      });
    }

    // Validar auto-geradas
    for (const secret of autoGeneratedSecrets) {
      const value = Deno.env.get(secret.name);
      const isPresent = value !== undefined && value !== null && value !== '';
      
      results.auto.push({
        name: secret.name,
        description: secret.description,
        category: secret.category,
        present: isPresent,
        status: isPresent ? 'ok' : 'missing'
      });
    }

    // Calcular estat√≠sticas
    const stats = {
      total_secrets: criticalSecrets.length + importantSecrets.length + autoGeneratedSecrets.length,
      critical_ok: results.critical.filter(s => s.present).length,
      critical_total: criticalSecrets.length,
      important_ok: results.important.filter(s => s.present).length,
      important_total: importantSecrets.length,
      auto_ok: results.auto.filter(s => s.present).length,
      auto_total: autoGeneratedSecrets.length
    };

    // Determinar status geral
    const overallStatus = allCriticalPresent ? 'healthy' : 'critical';
    
    const missingCritical = results.critical.filter(s => !s.present).map(s => s.name);
    const missingImportant = results.important.filter(s => !s.present).map(s => s.name);

    console.log('‚úÖ Valida√ß√£o conclu√≠da');
    console.log(`Status: ${overallStatus}`);
    console.log(`Cr√≠ticas: ${stats.critical_ok}/${stats.critical_total}`);
    console.log(`Importantes: ${stats.important_ok}/${stats.important_total}`);

    return new Response(
      JSON.stringify({
        status: overallStatus,
        all_critical_present: allCriticalPresent,
        stats,
        results,
        missing: {
          critical: missingCritical,
          important: missingImportant
        },
        message: allCriticalPresent 
          ? '‚úÖ Todas as secrets cr√≠ticas est√£o configuradas' 
          : `‚ö†Ô∏è ${missingCritical.length} secret(s) cr√≠tica(s) ausente(s)`,
        documentation_url: '/docs/SECRETS_RECOVERY_GUIDE.md',
        validated_at: new Date().toISOString()
      }),
      {
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      }
    );

  } catch (err) {
    const error = err as Error;
    console.error('‚ùå Erro ao validar secrets:', err);
    
    return new Response(
      JSON.stringify({
        error: 'Erro ao validar secrets',
        details: error.message,
        stack: error.stack
      }),
      {
        status: 500,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      }
    );
  }
});
